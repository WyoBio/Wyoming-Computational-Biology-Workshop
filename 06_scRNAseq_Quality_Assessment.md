# Quality assessment

We are going to begin our single-cell analysis by loading in the output from CellRanger. We will load in our different samples, create a Seurat object with them, and take a look at the quality of the cells.

The general steps to preprocessing your single-cell data with Seurat:

1. **Create a Seurat object**
2. **Filter low-quality cells**
3. **Merge samples**
4. **Normalize counts**
5. **Find variable features**
6. **Scale data**
7. **Determine PCs for Clustering**
8. **Clustering** - FindNeighbors, FindClusters, RunUMAP

### Setup
Begin by initiating a fresh R script and loading the essential packages. Among these, Seurat takes the spotlight. Renowned for its distinctive data structure and robust tools, Seurat facilitates quality control, analysis, and in-depth exploration of single-cell RNA sequencing data. Widely embraced, it stands as a staple in the realm of single-cell RNA analysis, setting a benchmark for its comprehensive functionality and reliability.

```R
library("Seurat") 
library("ggplot2") # creating plots
library("cowplot") # add-on to ggplot, we use the plot_grid function to put multiple violin plots in one image file
library("dplyr")   # a set of functions for data frame manipulation -- a core package of Tidyverse (THE R data manipulation package)
library("Matrix")  # a set of functions for operating on matrices
library("viridis") # color maps for graphs that are more readable than default colors
library("gprofiler2")

datadir = "/project/biocompworkshop/Data_Vault/scRNAseq"
outdir = "/project/biocompworkshop/rshukla/scRNASeq_Results"

setwd(datadir)
list.files()
```

### Initiating Data Import for a Single Sample
Next, we'll import our data matrix generated by Cellranger. Among Cellranger's output files, we'll focus on `sample_filtered_feature_bc_matrix.h5`, containing raw read counts for all cells per sample. Although not human-readable, you can envision it as a table where cell barcodes are column headers and genes (or features) are row names.

We're working with 3 replicates, grouped into pairs of ICB-treated and CD4-depleted ICB-treated samples.

The `CreateSeuratObject` function takes 4 parameters. First is the counts, sourced from the h5 files. The `project` parameter defines the Seurat object's identification, set as the sample name. We also add some filtering criteria: each gene must appear in at least 10 cells, and each cell must have at least 100 features (genes).

For example, processing two samples might look like this:

```R
# Read in the cellranger h5 file
Rep1_ICBdT_data = Read10X_h5("Rep1_ICBdT-sample_filtered_feature_bc_matrix.h5") 

Rep1_ICB_data = Read10X_h5("Rep1_ICB-sample_filtered_feature_bc_matrix.h5")

Rep1_ICBdT_data_seurat_obj = CreateSeuratObject(counts = Rep1_ICBdT_data, project = "Rep1_ICBdT", min.cells = 10, min.features = 100)

Rep1_ICB_data_seurat_obj = CreateSeuratObject(counts = Rep1_ICB_data, project = "Rep1_ICB", min.cells = 10, min.features = 100)
```
### Exploring the Seurat Object Structure
Let's familiarize ourselves with the structure of this Seurat object and understand how we can extract the information necessary for quality assessment, clustering, and subsequent analysis.

```R
print(Rep1_ICB_data_seurat_obj)
```

```
An object of class Seurat 
14423 features across 4169 samples within 1 assay 
Active assay: RNA (14423 features, 0 variable features)
 1 layer present: counts
```
We observe that our Seurat object comprises 14,423 features representing genes, 4,169 samples representing cells, and 1 assay representing our counts matrix.

```R
Assays(Rep1_ICB_data_seurat_obj) # seurat objects are made up of assays

Layers(Rep1_ICB_data_seurat_obj) # assays contain layers
```

The raw counts are stored in an assay labeled as RNA.

```R
Rep1_ICB_data_seurat_obj[["RNA"]] # an assay with layers
```

```
Assay (v5) data with 14423 features for 4169 cells
First 10 features:
 Mrpl15, Lypla1, Tcea1, Atp6v1h, Rb1cc1, 4732440D04Rik, Pcmtd1, Gm26901, Sntg1, Rrs1 
Layers:
 counts
```

Let's take a look at our counts.

```R
Rep1_ICB_data_seurat_obj[["RNA"]]$counts
```

```
14423 x 4169 sparse Matrix of class "dgCMatrix"
  [[ suppressing 59 column names ‘AAACCTGAGCGGATCA-1’, ‘AAACCTGCAAGAGGCT-1’, ‘AAACCTGCATACTCTT-1’ ... ]]
  [[ suppressing 59 column names ‘AAACCTGAGCGGATCA-1’, ‘AAACCTGCAAGAGGCT-1’, ‘AAACCTGCATACTCTT-1’ ... ]]
                                                                                                                                           
Mrpl15        . . . 1 . . . . . . . 1 1 . 2 . . . . . . . . 1 1 1 . . .  5 . . . 1 1 . . . 1 1 . . . . . . . . . . . . . . . 1 . . . ......
Lypla1        . . . 1 . . . . . . . . . . 1 1 . . . . . . . 2 1 . . 1 .  6 . . 1 . . . . . . 1 . . 1 . . . . . . . . . . . 1 . . . . ......
Tcea1         . . . . . . 2 . . . 1 . 1 . 1 . 2 1 1 . . . . . . . . . 1 20 . . 2 . 2 . 1 . 3 . . 1 1 . . . . 2 . 3 1 . 1 . . 3 . . 1 ......
Atp6v1h       . 1 . . . . . . . . . . 1 . . 1 . . . . . . . . 1 . 1 . .  2 . . . 2 1 . . . . . . 2 1 . 1 . . 1 2 . 1 . . . . . . . 1 ......
Rb1cc1        . . . . 2 . 1 . . . . . 3 . 1 1 . . . . . 1 . . 2 4 . . .  1 . . . 1 1 . . . 1 1 . . . . . 2 . 2 1 . 2 1 . . . . 2 1 . ......
4732440D04Rik . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1 . . . . . . . . 1 . . . . . . . . . . . 1 . . . . . . . . ......
Pcmtd1        . . . . . 1 . . . . . . . . . 1 1 . . . . 1 . . 1 . . 1 .  3 . . . . 1 . . . . . . . . 1 . 1 . . . . . . . . . . 1 1 . ......
Gm26901       . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ......

 ..............................
 ........suppressing 4110 columns and 14407 rows in show(); maybe adjust options(max.print=, width=)
 ..............................
```
Let's take a peek at our counts matrix. It's not particularly human-friendly to read or interpret directly. If we could visualize the entire matrix, it would resemble a table with cell barcodes as columns and genes as row names, where the numbers denote the observed reads of each gene in every cell.

We keep our more human-readable annotations in a section called `meta.data`. This section is much easier to interpret, with cell barcodes as row names and various labels as columns for each cell. As we delve into our data analysis, we'll add several columns to `meta.data`, so it's important to become accustomed to examining it! By default, `meta.data` includes three columns:

- `orig.ident`: denotes the sample origin of each cell
- `nCount_RNA`: indicates the total reads in each cell
- `nFeature_RNA`: shows the number of genes detected in each cell

```R
head(Rep1_ICB_data_seurat_obj@meta.data)
```
```
                   orig.ident nCount_RNA nFeature_RNA
AAACCTGAGCGGATCA-1   Rep1_ICB       5679         1758
AAACCTGCAAGAGGCT-1   Rep1_ICB       1397          496
AAACCTGCATACTCTT-1   Rep1_ICB       8463         2444
AAACCTGCATCATCCC-1   Rep1_ICB       4640         1721
AAACCTGGTTCGGGCT-1   Rep1_ICB       3810         1291
AAACCTGTCAGTCCCT-1   Rep1_ICB       7810         2079
```
Keep in mind that there are actually two methods to access the information stored in `meta.data`:

```R
# viewing meta.data
head(Rep1_ICB_data_seurat_obj@meta.data)

head(Rep1_ICB_data_seurat_obj[[]])

# viewing the orig.ident column in meta.data

head(Rep1_ICB_data_seurat_obj@meta.data$orig.ident)

head(Rep1_ICB_data_seurat_obj[['orig.ident']])
```
We can examine the cell identities using the `Idents` function. In our dataset, cell identities are determined by the `orig.ident` column in the `meta.data`. Upon using the `table` function to generate a summary, we observe that all cells originate from the same sample, which aligns with our expectation as we are currently focused on a single sample's Seurat object.

```R
Idents(Rep1_ICB_data_seurat_obj) # View cell identities

table(Idents(Rep1_ICB_data_seurat_obj)) # get summary table
```
Adding a column to `meta.data` is straightforward. To begin, let's add the percentage of mitochondrial genes, a crucial metric for identifying and removing low-quality cells later on. We'll name this column `percent.mt` and employ the `PercentageFeatureSet` function to compute the percentage of counts attributed to a specific subset of features in each cell. Using the `pattern` parameter, we'll match genes starting with "mt" (using the caret ^ character to denote "starts with"), and specify that this calculation should apply to our RNA assay.

```R
Rep1_ICB_data_seurat_obj[["percent.mt"]] = 
    PercentageFeatureSet(Rep1_ICB_data_seurat_obj, pattern = "^mt-", assay = "RNA")

head(Rep1_ICB_data_seurat_obj[[]]) # check to see the column in meta.data
```

We'll utilize `percent.mt` to evaluate the quality of our cells. Before proceeding to process all our samples, let's quickly examine this single-sample data. Through violin plots, we'll observe the number of reads, the number of genes, and the percentage of mitochondrial genes in each cell.

```R
p1 <- VlnPlot(Rep1_ICB_data_seurat_obj, features = c("nCount_RNA"), pt.size = 0) 
p2 <- VlnPlot(Rep1_ICB_data_seurat_obj, features = c("nFeature_RNA"), pt.size = 0) + scale_y_continuous(breaks = c(0, 300, 500, 1000, 2000, 4000))
p3 <- VlnPlot(Rep1_ICB_data_seurat_obj, features = c("percent.mt"), pt.size = 0) + scale_y_continuous(breaks = c(0, 12.5, 25, 50))
p <- plot_grid(p1, p2, p3, ncol = 3)
p
```

Upon observation, we note that a significant portion of cells possess more than 1000 genes and a mitochondrial percentage of less than 12. Cells deviating from this range likely indicate cell death or low quality, prompting us to filter them out.

### Simplifying Seurat Object Creation for Multiple Samples
The code above serves its purpose well, but it demands precise paths and sample names to function correctly. This leaves ample room for minor errors and can be time-consuming to write out each command manually.

#### for-loop to read in all six sample files
Our for-loop achieves two key tasks: reading in the cellranger files and creating Seurat objects. It can be interpreted as follows: "For each sample in the `sample_names` list, construct the path to locate the h5 file for that sample, print the path for verification, utilize the `Read10X_h5` function to read the h5 file, generate a Seurat object using `CreateSeuratObject`, and ultimately add that sample’s Seurat object to a list. Upon completing the for-loop, our `sample_data` list should encompass all six samples."

```R
# List of sample names
sample_names <- c("Rep1_ICBdT", "Rep1_ICB", "Rep3_ICBdT", "Rep3_ICB",
                  "Rep5_ICBdT", "Rep5_ICB")

sample.data  = list() # create a list to hold seurat object

for (sample in sample_names) {
  path = paste("/project/biocompworkshop/Data_Vault/scRNAseq/", sample, "-sample_filtered_feature_bc_matrix.h5", sep="") # paste together a path name for the h5 file
  print(path) # check to make sure the path is correct

  data = Read10X_h5(path) # read in the cellranger h5 file

  seurat_obj = CreateSeuratObject(counts = data, project = sample, min.cells = 10, min.features = 100)

  sample.data[[sample]] = seurat_obj # add sample seurat object to list
}
```
### Removing Low-Quality Cells
#### Compute the Percentage of Mitochondrial Genes per Cell
We'll replicate the process we used for a single sample to calculate the percentage of mitochondrial genes for each cell across all samples. Once again, we'll employ a for-loop to achieve this task efficiently for all samples.

```R
for (sample in sample_names) {
  sample.data[[sample]][["percent.mt"]] = 
    PercentageFeatureSet(sample.data[[sample]], pattern = "^mt-", assay = "RNA")
}
```
#### Observe the Cell Count Before Filtering

```R
for (sample in sample_names) {
  print(table(Idents(sample.data[[sample]]))) 
}
```
#### Violin Plots for Quality Assessment
We can generate violin plots to assess the cell quality across each sample. Spend some time reviewing these plots and consider the optimal threshold for eliminating low-quality cells.

```R
for (sample in sample_names) {
  print(sample)
  
  p1 <- VlnPlot(sample.data[[sample]], features = c("nCount_RNA"), pt.size = 0) 
  p2 <- VlnPlot(sample.data[[sample]], features = c("nFeature_RNA"), pt.size = 0) + scale_y_continuous(breaks = c(0, 300, 500, 1000, 2000, 4000))
  p3 <- VlnPlot(sample.data[[sample]], features = c("percent.mt"), pt.size = 0) + scale_y_continuous(breaks = c(0, 12.5, 25, 50))
  p <- plot_grid(p1, p2, p3, ncol = 3)
  
  print(p)
  
}
```
### Exclude Cells of Poor Quality Based on QC Plots
Suppose we opt to retain cells with gene counts exceeding 1000 and mitochondrial percentages below 12.

We'll designate cells we want to retain using the `ifelse` function. This statement reads: if `percent.mt` is less than or equal to 12, it will be marked as TRUE to keep it; otherwise, it will be marked as FALSE to filter it out.

```R
Rep1_ICB_data_seurat_obj[["keep_cell_percent.mt"]] = ifelse(Rep1_ICB_data_seurat_obj[["percent.mt"]] <= 12, TRUE, FALSE)

head(Rep1_ICB_data_seurat_obj[[]])
```
```
                   orig.ident nCount_RNA nFeature_RNA percent.mt keep_cell_percent.mt
AAACCTGAGCGGATCA-1   Rep1_ICB       5679         1758   2.341962                 TRUE
AAACCTGCAAGAGGCT-1   Rep1_ICB       1397          496  50.894775                FALSE
AAACCTGCATACTCTT-1   Rep1_ICB       8463         2444   2.197802                 TRUE
AAACCTGCATCATCCC-1   Rep1_ICB       4640         1721   3.750000                 TRUE
AAACCTGGTTCGGGCT-1   Rep1_ICB       3810         1291   2.755906                 TRUE
AAACCTGTCAGTCCCT-1   Rep1_ICB       7810         2079   3.354673                 TRUE
```

We'll apply the same process for the number of genes.

```R
Rep1_ICB_data_seurat_obj[["keep_cell_nFeature"]] = ifelse(Rep1_ICB_data_seurat_obj[["nFeature_RNA"]] > 1000, TRUE, FALSE)

head(Rep1_ICB_data_seurat_obj[[]])
```
```
                   orig.ident nCount_RNA nFeature_RNA percent.mt keep_cell_percent.mt keep_cell_nFeature
AAACCTGAGCGGATCA-1   Rep1_ICB       5679         1758   2.341962                 TRUE               TRUE
AAACCTGCAAGAGGCT-1   Rep1_ICB       1397          496  50.894775                FALSE              FALSE
AAACCTGCATACTCTT-1   Rep1_ICB       8463         2444   2.197802                 TRUE               TRUE
AAACCTGCATCATCCC-1   Rep1_ICB       4640         1721   3.750000                 TRUE               TRUE
AAACCTGGTTCGGGCT-1   Rep1_ICB       3810         1291   2.755906                 TRUE               TRUE
AAACCTGTCAGTCCCT-1   Rep1_ICB       7810         2079   3.354673                 TRUE               TRUE
```
Generate this column across all samples:

```R
for (sample in sample_names) {
  sample.data[[sample]][["keep_cell_percent.mt"]] = ifelse(sample.data[[sample]][["percent.mt"]] <= 12, TRUE, FALSE)
  sample.data[[sample]][["keep_cell_nFeature"]] = ifelse(sample.data[[sample]][["nFeature_RNA"]] > 1000, TRUE, FALSE)

}
```

Now, let's check the cell count post-filtering:

```R
for (sample in sample_names) {
  print(sample)
  print(sum(sample.data[[sample]][["keep_cell_nFeature"]] & sample.data[[sample]][["keep_cell_percent.mt"]]))
}
```

### Cell Count After Filtering
We'll utilize the `subset` function to observe the distribution of our data post-filtering.

```R
for (sample in sample_names) {
  print(sample)
  
  p1 <- VlnPlot(subset(sample.data[[sample]], nFeature_RNA > 1000 & percent.mt <= 12), features = c("nCount_RNA"), pt.size = 0) 
  p2 <- VlnPlot(subset(sample.data[[sample]], nFeature_RNA > 1000 & percent.mt <= 12), features = c("nFeature_RNA"), pt.size = 0) + scale_y_continuous(breaks = c(0, 300, 500, 1000, 2000, 4000))
  p3 <- VlnPlot(subset(sample.data[[sample]], nFeature_RNA > 1000 & percent.mt <= 12), features = c("percent.mt"), pt.size = 0) + scale_y_continuous(breaks = c(0, 12.5, 25, 50))
  p <- plot_grid(p1, p2, p3, ncol = 3)
  
  print(p)
  
}
```
### Combine the Samples
Now that we've evaluated quality at the sample level, we can merge all samples into a single Seurat object. The `Merge` function will handle this task and append the sample name to cell barcodes if there are duplicates across samples.

```R
sample_names <- c("Rep1_ICBdT", "Rep1_ICB", "Rep3_ICBdT", "Rep3_ICB",
                  "Rep5_ICBdT", "Rep5_ICB")

merged <- merge(x = sample.data[["Rep1_ICBdT"]], y = c(sample.data[["Rep1_ICB"]], sample.data[["Rep3_ICBdT"]], sample.data[["Rep3_ICB"]], sample.data[["Rep5_ICBdT"]], sample.data[["Rep5_ICB"]]), add.cell.ids = sample_names)  
```
### Data Filtering 
Next, let's apply the previously determined cutoffs to filter out merged objects.

```R
unfiltered_merged <- merged # save a copy of unfiltered merge for later
merged <- subset(merged, nFeature_RNA > 1000 & percent.mt <= 12) 
merged
```
```
An object of class Seurat 
18187 features across 23185 samples within 1 assay 
Active assay: RNA (18187 features, 0 variable features)
 6 layers present: counts.Rep1_ICBdT, counts.Rep1_ICB, counts.Rep3_ICBdT, counts.Rep3_ICB, counts.Rep5_ICBdT, counts.Rep5_ICB
```
Currently, the different replicates exist in separate layers. To proceed with analysis, they must be merged into a single layer.

```R
merged <- JoinLayers(merged)
merged
```
```
An object of class Seurat 
18187 features across 23185 samples within 1 assay 
Active assay: RNA (18187 features, 0 variable features)
 1 layer present: counts
```
We can utilize `Idents` to confirm that all cells are present in our merged object.

```R
Idents(merged) # View cell identities

table(Idents(merged)) # get summary table
```
### Data Normalization
It's standard practice in scRNA data analysis to normalize counts. Numerous functions exclusively operate on normalized counts, ignoring raw counts. The `NormalizeData` function, applied to our merged object, log normalizes our RNA assay. Here, log normalization entails dividing the feature counts by each cell's total counts, multiplying by the scale factor, and then natural-log transforming using log1p.

```R
merged <- NormalizeData(merged, assay = "RNA", normalization.method = "LogNormalize", scale.factor = 10000)

merged
```
```
An object of class Seurat 
18187 features across 23185 samples within 1 assay 
Active assay: RNA (18187 features, 0 variable features)
 2 layers present: counts, data
```























