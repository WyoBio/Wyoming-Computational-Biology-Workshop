# Quality assessment

We are going to begin our single-cell analysis by loading in the output from CellRanger. We will load in our different samples, create a Seurat object with them, and take a look at the quality of the cells.

The general steps to preprocessing your single-cell data with Seurat:

1. **Create a Seurat object**
2. **Filter low-quality cells**
3. **Merge samples**
4. **Normalize counts**
5. **Find variable features**
6. **Scale data**
7. **Determine PCs for Clustering**
8. **Clustering** - FindNeighbors, FindClusters, RunUMAP

### Setup
Begin by initiating a fresh R script and loading the essential packages. Among these, Seurat takes the spotlight. Renowned for its distinctive data structure and robust tools, Seurat facilitates quality control, analysis, and in-depth exploration of single-cell RNA sequencing data. Widely embraced, it stands as a staple in the realm of single-cell RNA analysis, setting a benchmark for its comprehensive functionality and reliability.

```R
library("Seurat") 
library("ggplot2") # creating plots
library("cowplot") # add-on to ggplot, we use the plot_grid function to put multiple violin plots in one image file
library("dplyr")   # a set of functions for data frame manipulation -- a core package of Tidyverse (THE R data manipulation package)
library("Matrix")  # a set of functions for operating on matrices
library("viridis") # color maps for graphs that are more readable than default colors
library("gprofiler2")

datadir = "/project/biocompworkshop/Data_Vault/scRNAseq"
outdir = "/project/biocompworkshop/rshukla/scRNASeq_Results"

setwd(datadir)
list.files()
```

### Initiating Data Import for a Single Sample
Next, we'll import our data matrix generated by Cellranger. Among Cellranger's output files, we'll focus on `sample_filtered_feature_bc_matrix.h5`, containing raw read counts for all cells per sample. Although not human-readable, you can envision it as a table where cell barcodes are column headers and genes (or features) are row names.

We're working with 3 replicates, grouped into pairs of ICB-treated and CD4-depleted ICB-treated samples.

The `CreateSeuratObject` function takes 4 parameters. First is the counts, sourced from the h5 files. The `project` parameter defines the Seurat object's identification, set as the sample name. We also add some filtering criteria: each gene must appear in at least 10 cells, and each cell must have at least 100 features (genes).

For example, processing two samples might look like this:

```R
# Read in the cellranger h5 file
Rep1_ICBdT_data = Read10X_h5("Rep1_ICBdT-sample_filtered_feature_bc_matrix.h5") 

Rep1_ICB_data = Read10X_h5("Rep1_ICB-sample_filtered_feature_bc_matrix.h5")

Rep1_ICBdT_data_seurat_obj = CreateSeuratObject(counts = Rep1_ICBdT_data, project = "Rep1_ICBdT", min.cells = 10, min.features = 100)

Rep1_ICB_data_seurat_obj = CreateSeuratObject(counts = Rep1_ICB_data, project = "Rep1_ICB", min.cells = 10, min.features = 100)
```
### Exploring the Seurat Object Structure
Let's familiarize ourselves with the structure of this Seurat object and understand how we can extract the information necessary for quality assessment, clustering, and subsequent analysis.

```R
print(Rep1_ICB_data_seurat_obj)
```

```
An object of class Seurat 
14423 features across 4169 samples within 1 assay 
Active assay: RNA (14423 features, 0 variable features)
 1 layer present: counts
```
We observe that our Seurat object comprises 14,423 features representing genes, 4,169 samples representing cells, and 1 assay representing our counts matrix.

```R
Assays(Rep1_ICB_data_seurat_obj) # seurat objects are made up of assays

Layers(Rep1_ICB_data_seurat_obj) # assays contain layers
```

The raw counts are stored in an assay labeled as RNA.

```R
Rep1_ICB_data_seurat_obj[["RNA"]] # an assay with layers
```

```
Assay (v5) data with 14423 features for 4169 cells
First 10 features:
 Mrpl15, Lypla1, Tcea1, Atp6v1h, Rb1cc1, 4732440D04Rik, Pcmtd1, Gm26901, Sntg1, Rrs1 
Layers:
 counts
```

Let's take a look at our counts.

```R
Rep1_ICB_data_seurat_obj[["RNA"]]$counts
```

```
14423 x 4169 sparse Matrix of class "dgCMatrix"
  [[ suppressing 59 column names ‘AAACCTGAGCGGATCA-1’, ‘AAACCTGCAAGAGGCT-1’, ‘AAACCTGCATACTCTT-1’ ... ]]
  [[ suppressing 59 column names ‘AAACCTGAGCGGATCA-1’, ‘AAACCTGCAAGAGGCT-1’, ‘AAACCTGCATACTCTT-1’ ... ]]
                                                                                                                                           
Mrpl15        . . . 1 . . . . . . . 1 1 . 2 . . . . . . . . 1 1 1 . . .  5 . . . 1 1 . . . 1 1 . . . . . . . . . . . . . . . 1 . . . ......
Lypla1        . . . 1 . . . . . . . . . . 1 1 . . . . . . . 2 1 . . 1 .  6 . . 1 . . . . . . 1 . . 1 . . . . . . . . . . . 1 . . . . ......
Tcea1         . . . . . . 2 . . . 1 . 1 . 1 . 2 1 1 . . . . . . . . . 1 20 . . 2 . 2 . 1 . 3 . . 1 1 . . . . 2 . 3 1 . 1 . . 3 . . 1 ......
Atp6v1h       . 1 . . . . . . . . . . 1 . . 1 . . . . . . . . 1 . 1 . .  2 . . . 2 1 . . . . . . 2 1 . 1 . . 1 2 . 1 . . . . . . . 1 ......
Rb1cc1        . . . . 2 . 1 . . . . . 3 . 1 1 . . . . . 1 . . 2 4 . . .  1 . . . 1 1 . . . 1 1 . . . . . 2 . 2 1 . 2 1 . . . . 2 1 . ......
4732440D04Rik . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1 . . . . . . . . 1 . . . . . . . . . . . 1 . . . . . . . . ......
Pcmtd1        . . . . . 1 . . . . . . . . . 1 1 . . . . 1 . . 1 . . 1 .  3 . . . . 1 . . . . . . . . 1 . 1 . . . . . . . . . . 1 1 . ......
Gm26901       . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ......

 ..............................
 ........suppressing 4110 columns and 14407 rows in show(); maybe adjust options(max.print=, width=)
 ..............................
```
Let's take a peek at our counts matrix. It's not particularly human-friendly to read or interpret directly. If we could visualize the entire matrix, it would resemble a table with cell barcodes as columns and genes as row names, where the numbers denote the observed reads of each gene in every cell.

We keep our more human-readable annotations in a section called `meta.data`. This section is much easier to interpret, with cell barcodes as row names and various labels as columns for each cell. As we delve into our data analysis, we'll add several columns to `meta.data`, so it's important to become accustomed to examining it! By default, `meta.data` includes three columns:

- `orig.ident`: denotes the sample origin of each cell
- `nCount_RNA`: indicates the total reads in each cell
- `nFeature_RNA`: shows the number of genes detected in each cell

```R
head(Rep1_ICB_data_seurat_obj@meta.data)
```
```
                   orig.ident nCount_RNA nFeature_RNA
AAACCTGAGCGGATCA-1   Rep1_ICB       5679         1758
AAACCTGCAAGAGGCT-1   Rep1_ICB       1397          496
AAACCTGCATACTCTT-1   Rep1_ICB       8463         2444
AAACCTGCATCATCCC-1   Rep1_ICB       4640         1721
AAACCTGGTTCGGGCT-1   Rep1_ICB       3810         1291
AAACCTGTCAGTCCCT-1   Rep1_ICB       7810         2079
```
Keep in mind that there are actually two methods to access the information stored in `meta.data`:

```R
# viewing meta.data
head(Rep1_ICB_data_seurat_obj@meta.data)

head(Rep1_ICB_data_seurat_obj[[]])

# viewing the orig.ident column in meta.data

head(Rep1_ICB_data_seurat_obj@meta.data$orig.ident)

head(Rep1_ICB_data_seurat_obj[['orig.ident']])
```
We can examine the cell identities using the `Idents` function. In our dataset, cell identities are determined by the `orig.ident` column in the `meta.data`. Upon using the `table` function to generate a summary, we observe that all cells originate from the same sample, which aligns with our expectation as we are currently focused on a single sample's Seurat object.

```R
Idents(Rep1_ICB_data_seurat_obj) # View cell identities

table(Idents(Rep1_ICB_data_seurat_obj)) # get summary table
```
Adding a column to `meta.data` is straightforward. To begin, let's add the percentage of mitochondrial genes, a crucial metric for identifying and removing low-quality cells later on. We'll name this column `percent.mt` and employ the `PercentageFeatureSet` function to compute the percentage of counts attributed to a specific subset of features in each cell. Using the `pattern` parameter, we'll match genes starting with "mt" (using the caret ^ character to denote "starts with"), and specify that this calculation should apply to our RNA assay.

```R
Rep1_ICB_data_seurat_obj[["percent.mt"]] = 
    PercentageFeatureSet(Rep1_ICB_data_seurat_obj, pattern = "^mt-", assay = "RNA")

head(Rep1_ICB_data_seurat_obj[[]]) # check to see the column in meta.data
```

We'll utilize `percent.mt` to evaluate the quality of our cells. Before proceeding to process all our samples, let's quickly examine this single-sample data. Through violin plots, we'll observe the number of reads, the number of genes, and the percentage of mitochondrial genes in each cell.

```R
p1 <- VlnPlot(Rep1_ICB_data_seurat_obj, features = c("nCount_RNA"), pt.size = 0) 
p2 <- VlnPlot(Rep1_ICB_data_seurat_obj, features = c("nFeature_RNA"), pt.size = 0) + scale_y_continuous(breaks = c(0, 300, 500, 1000, 2000, 4000))
p3 <- VlnPlot(Rep1_ICB_data_seurat_obj, features = c("percent.mt"), pt.size = 0) + scale_y_continuous(breaks = c(0, 12.5, 25, 50))
p <- plot_grid(p1, p2, p3, ncol = 3)
p
```

Upon observation, we note that a significant portion of cells possess more than 1000 genes and a mitochondrial percentage of less than 12. Cells deviating from this range likely indicate cell death or low quality, prompting us to filter them out.

### Simplifying Seurat Object Creation for Multiple Samples
The code above serves its purpose well, but it demands precise paths and sample names to function correctly. This leaves ample room for minor errors and can be time-consuming to write out each command manually.

#### for-loop to read in all six sample files
Our for-loop achieves two key tasks: reading in the cellranger files and creating Seurat objects. It can be interpreted as follows: "For each sample in the `sample_names` list, construct the path to locate the h5 file for that sample, print the path for verification, utilize the `Read10X_h5` function to read the h5 file, generate a Seurat object using `CreateSeuratObject`, and ultimately add that sample’s Seurat object to a list. Upon completing the for-loop, our `sample_data` list should encompass all six samples."

```R
# List of sample names
sample_names <- c("Rep1_ICBdT", "Rep1_ICB", "Rep3_ICBdT", "Rep3_ICB",
                  "Rep5_ICBdT", "Rep5_ICB")

sample.data  = list() # create a list to hold seurat object

for (sample in sample_names) {
  path = paste("/project/biocompworkshop/Data_Vault/scRNAseq/", sample, "-sample_filtered_feature_bc_matrix.h5", sep="") # paste together a path name for the h5 file
  print(path) # check to make sure the path is correct

  data = Read10X_h5(path) # read in the cellranger h5 file

  seurat_obj = CreateSeuratObject(counts = data, project = sample, min.cells = 10, min.features = 100)

  sample.data[[sample]] = seurat_obj # add sample seurat object to list
}
```
### Removing Low-Quality Cells
#### Compute the Percentage of Mitochondrial Genes per Cell
We'll replicate the process we used for a single sample to calculate the percentage of mitochondrial genes for each cell across all samples. Once again, we'll employ a for-loop to achieve this task efficiently for all samples.

```R
for (sample in sample_names) {
  sample.data[[sample]][["percent.mt"]] = 
    PercentageFeatureSet(sample.data[[sample]], pattern = "^mt-", assay = "RNA")
}
```
#### Observe the Cell Count Before Filtering

```R
for (sample in sample_names) {
  print(table(Idents(sample.data[[sample]]))) 
}
```
#### Violin Plots for Quality Assessment
We can generate violin plots to assess the cell quality across each sample. Spend some time reviewing these plots and consider the optimal threshold for eliminating low-quality cells.

```R
for (sample in sample_names) {
  print(sample)
  
  p1 <- VlnPlot(sample.data[[sample]], features = c("nCount_RNA"), pt.size = 0) 
  p2 <- VlnPlot(sample.data[[sample]], features = c("nFeature_RNA"), pt.size = 0) + scale_y_continuous(breaks = c(0, 300, 500, 1000, 2000, 4000))
  p3 <- VlnPlot(sample.data[[sample]], features = c("percent.mt"), pt.size = 0) + scale_y_continuous(breaks = c(0, 12.5, 25, 50))
  p <- plot_grid(p1, p2, p3, ncol = 3)
  
  print(p)
  
}
```
### Exclude Cells of Poor Quality Based on QC Plots
Suppose we opt to retain cells with gene counts exceeding 1000 and mitochondrial percentages below 12.

We'll designate cells we want to retain using the `ifelse` function. This statement reads: if `percent.mt` is less than or equal to 12, it will be marked as TRUE to keep it; otherwise, it will be marked as FALSE to filter it out.

```R
Rep1_ICB_data_seurat_obj[["keep_cell_percent.mt"]] = ifelse(Rep1_ICB_data_seurat_obj[["percent.mt"]] <= 12, TRUE, FALSE)

head(Rep1_ICB_data_seurat_obj[[]])
```
```
                   orig.ident nCount_RNA nFeature_RNA percent.mt keep_cell_percent.mt
AAACCTGAGCGGATCA-1   Rep1_ICB       5679         1758   2.341962                 TRUE
AAACCTGCAAGAGGCT-1   Rep1_ICB       1397          496  50.894775                FALSE
AAACCTGCATACTCTT-1   Rep1_ICB       8463         2444   2.197802                 TRUE
AAACCTGCATCATCCC-1   Rep1_ICB       4640         1721   3.750000                 TRUE
AAACCTGGTTCGGGCT-1   Rep1_ICB       3810         1291   2.755906                 TRUE
AAACCTGTCAGTCCCT-1   Rep1_ICB       7810         2079   3.354673                 TRUE
```

We'll apply the same process for the number of genes.

```R
Rep1_ICB_data_seurat_obj[["keep_cell_nFeature"]] = ifelse(Rep1_ICB_data_seurat_obj[["nFeature_RNA"]] > 1000, TRUE, FALSE)

head(Rep1_ICB_data_seurat_obj[[]])
```
```
                   orig.ident nCount_RNA nFeature_RNA percent.mt keep_cell_percent.mt keep_cell_nFeature
AAACCTGAGCGGATCA-1   Rep1_ICB       5679         1758   2.341962                 TRUE               TRUE
AAACCTGCAAGAGGCT-1   Rep1_ICB       1397          496  50.894775                FALSE              FALSE
AAACCTGCATACTCTT-1   Rep1_ICB       8463         2444   2.197802                 TRUE               TRUE
AAACCTGCATCATCCC-1   Rep1_ICB       4640         1721   3.750000                 TRUE               TRUE
AAACCTGGTTCGGGCT-1   Rep1_ICB       3810         1291   2.755906                 TRUE               TRUE
AAACCTGTCAGTCCCT-1   Rep1_ICB       7810         2079   3.354673                 TRUE               TRUE
```
Generate this column across all samples:

```R
for (sample in sample_names) {
  sample.data[[sample]][["keep_cell_percent.mt"]] = ifelse(sample.data[[sample]][["percent.mt"]] <= 12, TRUE, FALSE)
  sample.data[[sample]][["keep_cell_nFeature"]] = ifelse(sample.data[[sample]][["nFeature_RNA"]] > 1000, TRUE, FALSE)

}
```

Now, let's check the cell count post-filtering:

```R
for (sample in sample_names) {
  print(sample)
  print(sum(sample.data[[sample]][["keep_cell_nFeature"]] & sample.data[[sample]][["keep_cell_percent.mt"]]))
}
```

### Cell Count After Filtering
We'll utilize the `subset` function to observe the distribution of our data post-filtering.

```R
for (sample in sample_names) {
  print(sample)
  
  p1 <- VlnPlot(subset(sample.data[[sample]], nFeature_RNA > 1000 & percent.mt <= 12), features = c("nCount_RNA"), pt.size = 0) 
  p2 <- VlnPlot(subset(sample.data[[sample]], nFeature_RNA > 1000 & percent.mt <= 12), features = c("nFeature_RNA"), pt.size = 0) + scale_y_continuous(breaks = c(0, 300, 500, 1000, 2000, 4000))
  p3 <- VlnPlot(subset(sample.data[[sample]], nFeature_RNA > 1000 & percent.mt <= 12), features = c("percent.mt"), pt.size = 0) + scale_y_continuous(breaks = c(0, 12.5, 25, 50))
  p <- plot_grid(p1, p2, p3, ncol = 3)
  
  print(p)
  
}
```
### Combine the Samples
Now that we've evaluated quality at the sample level, we can merge all samples into a single Seurat object. The `Merge` function will handle this task and append the sample name to cell barcodes if there are duplicates across samples.

```R
sample_names <- c("Rep1_ICBdT", "Rep1_ICB", "Rep3_ICBdT", "Rep3_ICB",
                  "Rep5_ICBdT", "Rep5_ICB")

merged <- merge(x = sample.data[["Rep1_ICBdT"]], y = c(sample.data[["Rep1_ICB"]], sample.data[["Rep3_ICBdT"]], sample.data[["Rep3_ICB"]], sample.data[["Rep5_ICBdT"]], sample.data[["Rep5_ICB"]]), add.cell.ids = sample_names)  
```
### Data Filtering 
Next, let's apply the previously determined cutoffs to filter out merged objects.

```R
unfiltered_merged <- merged # save a copy of unfiltered merge for later
merged <- subset(merged, nFeature_RNA > 1000 & percent.mt <= 12) 
merged
```
```
An object of class Seurat 
18187 features across 23185 samples within 1 assay 
Active assay: RNA (18187 features, 0 variable features)
 6 layers present: counts.Rep1_ICBdT, counts.Rep1_ICB, counts.Rep3_ICBdT, counts.Rep3_ICB, counts.Rep5_ICBdT, counts.Rep5_ICB
```
Currently, the different replicates exist in separate layers. To proceed with analysis, they must be merged into a single layer.

```R
merged <- JoinLayers(merged)
merged
```
```
An object of class Seurat 
18187 features across 23185 samples within 1 assay 
Active assay: RNA (18187 features, 0 variable features)
 1 layer present: counts
```
We can utilize `Idents` to confirm that all cells are present in our merged object.

```R
Idents(merged) # View cell identities

table(Idents(merged)) # get summary table
```
### Data Normalization
It's standard practice in scRNA data analysis to normalize counts. Numerous functions exclusively operate on normalized counts, ignoring raw counts. The `NormalizeData` function, applied to our merged object, log normalizes our RNA assay. Here, log normalization entails dividing the feature counts by each cell's total counts, multiplying by the scale factor, and then natural-log transforming using log1p.

```R
merged <- NormalizeData(merged, assay = "RNA", normalization.method = "LogNormalize", scale.factor = 10000)

merged
```
```
An object of class Seurat 
18187 features across 23185 samples within 1 assay 
Active assay: RNA (18187 features, 0 variable features)
 2 layers present: counts, data
```
### Identify Variable Features
Next, we'll pinpoint genes that exhibit high expression in certain cells and low expression in others, identified as outliers on a 'mean variability plot.' We'll employ `vst` to select the top variable features, which will be instrumental in downstream analysis, such as PCA.

```R
merged <- FindVariableFeatures(merged, assay = "RNA", selection.method = "vst", nfeatures = 2000, mean.cutoff = c(0.1, 8), dispersion.cutoff = c(1,Inf))
```
We can depict the highly variable genes using a dot plot.

```R
# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(merged), 10)
top10

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(object=merged)
HoverLocator(plot = plot1)
```
Understanding where the information about the variable features is stored can be a bit challenging.

```R
merged[["RNA"]]
```
```
Assay (v5) data with 18187 features for 23185 cells
Top 10 variable features:
 Jchain, Ighg1, Igkc, Sprr2d, Mzb1, Slpi, Sprr2f, Sprr2h, Saa3, Cxcl3 
Layers:
 counts, data
```
### Scale Data
Now we will scale and center the genes in the dataset.

```R
merged <- ScaleData(merged, verbose = TRUE) 

merged
```
```
An object of class Seurat 
18187 features across 23185 samples within 1 assay 
Active assay: RNA (18187 features, 2000 variable features)
 3 layers present: counts, data, scale.data
```
### Scoring Cell Cycle
Incorporating Cell Cycle scoring is a valuable step that enhances the information within your Seurat object. We'll utilize gprofiler2 to extract a list of mouse genes linked to various phases of the cell cycle. Subsequently, the Seurat function 'CellCycleScoring' will compute a score for each cell using these specified genes and assign a phase to each cell. This process will augment the meta.data with the columns S.Score, G2M.Score, and Phase.

```R
s.genes = gorth(cc.genes.updated.2019$s.genes, source_organism = "hsapiens", target_organism = "mmusculus")$ortholog_name
g2m.genes = gorth(cc.genes.updated.2019$g2m.genes, source_organism = "hsapiens", target_organism = "mmusculus")$ortholog_name

merged <- CellCycleScoring(object=merged, s.features=s.genes, g2m.features=g2m.genes, set.ident=FALSE)

head(merged[[]])
```
```
                              orig.ident nCount_RNA nFeature_RNA percent.mt keep_cell_percent.mt keep_cell_nFeature     S.Score   G2M.Score Phase
Rep1_ICBdT_AAACCTGAGCCAACAG-1 Rep1_ICBdT      20585         4384   1.675978                 TRUE               TRUE  0.61857647  0.19639961     S
Rep1_ICBdT_AAACCTGAGCCTTGAT-1 Rep1_ICBdT       4528         1967   3.577739                 TRUE               TRUE -0.06225445 -0.13230705    G1
Rep1_ICBdT_AAACCTGAGTACCGGA-1 Rep1_ICBdT      12732         3327   2.764687                 TRUE               TRUE -0.14015383 -0.17780932    G1
Rep1_ICBdT_AAACCTGCACGGCCAT-1 Rep1_ICBdT       4903         2074   1.427697                 TRUE               TRUE -0.05258375 -0.06400598    G1
Rep1_ICBdT_AAACCTGCACGGTAAG-1 Rep1_ICBdT      10841         3183   2.472097                 TRUE               TRUE -0.10176717 -0.06637093    G1
Rep1_ICBdT_AAACCTGCATGCCACG-1 Rep1_ICBdT      10981         2788   2.030780                 TRUE               TRUE -0.08794336 -0.21230015    G1
```
### Decide on the Number of PCs for Clustering
Examining the count matrix of our Seurat object serves as a reminder that processing the sheer number of genes and cells visually is impractical. We require a method to compress this information into a format that's more manageable and interpretable. Principal Component Analysis (PCA) is a dimension reduction strategy designed to capture similarities while retaining the underlying patterns that drive variation.

Imagine if we had just two cells and a few genes. Plotted on an x-y graph, with one cell's gene expression on the x-axis and the other on the y-axis, we'd see a simple dot plot. Drawing lines through these points would measure the spread of data points in two directions—these lines are principal components (PCs). They summarize the data points into a single, more understandable entity.

Adding another cell introduces another axis to our graph and another direction of potential variation. For our dataset's 23,185 cells, we have 23,185 directions of variation or principal components (PCs). PC1 represents the direction that captures the most variance.

### Calculating PCAs
Let's compute the Principal Components (PCs) for our dataset. We'll calculate the default 50 PCs, which should encompass a substantial amount of information for this dataset.

```R
merged <- RunPCA(merged, npcs = 50, assay = "RNA") 

merged
```
```
An object of class Seurat 
18187 features across 23185 samples within 1 assay 
Active assay: RNA (18187 features, 2000 variable features)
 3 layers present: counts, data, scale.data
 1 dimensional reduction calculated: pca
```
```R
merged[["pca"]]
```
```
A dimensional reduction object with key PC_ 
 Number of dimensions: 50 
 Number of cells: 23185 
 Projected dimensional reduction calculated:  FALSE 
 Jackstraw run: FALSE 
 Computed using assay: RNA
```
After calculating the PCs, each cell is then "fitted" into the context of those PCs. This involves determining for each cell, "What is the cell's score or embedding for a specific PC based on gene expression in that cell?

```R
head(Embeddings(merged, reduction = "pca")[, 1:5])
```
```
                                    PC_1        PC_2        PC_3      PC_4       PC_5
Rep1_ICBdT_AAACCTGAGCCAACAG-1   3.835173  -0.8115711   9.8921410 2.2594305 14.1203451
Rep1_ICBdT_AAACCTGAGCCTTGAT-1   3.663907  -2.2085850  -1.2447077 1.2005316 -1.6541640
Rep1_ICBdT_AAACCTGAGTACCGGA-1 -65.634614 -46.0958039  -9.3464346 7.9993856  3.6250345
Rep1_ICBdT_AAACCTGCACGGCCAT-1   4.139736  -0.8617120  -0.3006448 0.4993232 -0.6362336
Rep1_ICBdT_AAACCTGCACGGTAAG-1   3.905916  -0.3761172   1.3514115 1.0349043  3.2202961
Rep1_ICBdT_AAACCTGCATGCCACG-1 -67.302103 -45.6771707 -11.5863126 3.4400124  4.9678837
```
### Visualizing PCAs
Now, the task is to identify the most crucial PCs that capture both similarity and diversity without excessive noise. Multiple methods exist for analyzing your PCs.

#### Elbow Plot
A widely used method for comprehending PCs is through an elbow plot. The PC identified as the 'elbow' point is where the standard deviation ceases to decrease dramatically and stabilizes.

```R
elbow <- ElbowPlot(merged, ndims = 30)

print(elbow)
```
### Dimension Heat maps
Another approach to understanding PCs is through heatmaps. These visualizations reveal the key genes influencing each PC and their expression levels across cells. The goal is to create heatmaps that display clear contrast instead of appearing as a messy blur. Importantly, we examine which genes are driving the PC and ensure that our PCs include relevant genes based on our analysis goals.

```R
DimHeatmap(merged, dims = 1:12, balanced = TRUE, cells = 500)

DimHeatmap(merged, dims = 13:24, balanced = TRUE, cells = 500)

DimHeatmap(merged, dims = 25:36, balanced = TRUE, cells = 500)
```
### Jackstraw
Jackstraw is an older and computationally intensive method for assessing the variability of PCs. While it may be resource-intensive, it can provide valuable insights into which PCs to prioritize. Typically, p-values above -100 are considered indicative of useful PCs.

```R
merged <- JackStraw(merged, num.replicate = 100, dims = 30)
merged <- ScoreJackStraw(merged, dims = 1:30)
plot <- JackStrawPlot(merged, dims = 1:30)
print(plot)
```
### Selecting the Number of PCs
By employing the elbow, heatmap, and potentially jackstraw methods, we can make an informed decision on the number of PCs to use for cell clustering. Our goal is to include as much information as possible without introducing excessive noise.

Another strategy to determine our PC cutoff involves examining how many PCs have a standard deviation exceeding 2.

```R
ndims = length(which(merged@reductions$pca@stdev > 2)) # determines which PCs are important (stdev>2) 
ndims
```

After reviewing the elbow plot, the PC heatmaps, and potentially the JackStraw plot (considering its computation time), we've chosen to use 26 PCs. This decision offers a great opportunity to experiment and observe the impact of adding or removing PCs. When unsure, erring on the side of slightly more PCs is preferable to having too few.

### Cell Clustering
We're now at the Cell Clustering stage. The initial step is FindNeighbors, which calculates the k.param nearest neighbors for a given dataset. This process involves identifying the closest data points to a given data point based on a similarity metric like Euclidean distance or cosine similarity. This helps in pinpointing similar points in the dataset, aiding in predictions or grasping the data's distribution.

```R
PC = 22

merged <- FindNeighbors(merged, dims = 1:PC)
```

Next, we execute FindClusters to group our cells based on similarity. While FindNeighbors targets the nearest neighbors of a single data point, FindClusters clusters multiple data points together based on their similarities.

```R
merged <- FindClusters(merged, resolution = 1.2, cluster.name = 'seurat_clusters_res1.2')
```

Lastly, we arrive at RunUMAP, which utilizes the clustering information to project our cells into a 2D space, facilitating visualization.

```R
merged <- RunUMAP(merged, dims = 1:PC)

merged
```
```
An object of class Seurat 
18187 features across 23185 samples within 1 assay 
Active assay: RNA (18187 features, 2000 variable features)
 3 layers present: counts, data, scale.data
 2 dimensional reductions calculated: pca, umap
```

### Plotting
Let’s view our clusters with DimPlot.

```R
DimPlot(merged, label = TRUE, group.by = 'seurat_clusters_res1.2')
```

Let's color the clusters by our samples to ensure that no sample is clustering independently. This would indicate potential batch effects. Our goal is to have similar cells clustered together based on gene expression similarities, not due to technical factors like different sequencing batches or replicates.

```R
# UMAP by sample
DimPlot(merged, label = TRUE, group.by = "orig.ident")
```

Our samples appear well mixed! To further confirm, we can highlight the cells from one sample and observe their distribution within the clusters.

```R
# UMAP with one day highlighted (not saved)
highlighted_cells <- WhichCells(merged, expression = orig.ident == "Rep1_ICBdT")
DimPlot(merged, reduction = 'umap', group.by = 'orig.ident', cells.highlight = highlighted_cells)
```

Let's delve into the cell cycle scoring calculations.

```R
FeaturePlot(merged, features = c("S.Score", "G2M.Score")) + DimPlot(merged,  group.by = "Phase")
```

### Exploring Clustering Resolution
Now, let's delve into the intricacies of clustering resolution. Selecting cluster resolution is somewhat arbitrary and impacts the number of clusters identified (higher resolution implies more clusters). Notably, altering the cluster resolution doesn't change the shape of the UMAP. The UMAP's shape is influenced by the number of PCs used to construct it.

```R
merged <- FindClusters(merged, resolution = 0.8, cluster.name = 'seurat_clusters_res0.8')

merged <- FindClusters(merged, resolution = 0.5, cluster.name = 'seurat_clusters_res0.5')

DimPlot(merged, label = TRUE, group.by = 'seurat_clusters_res0.5') +
  DimPlot(merged, label = TRUE, group.by = 'seurat_clusters_res0.8') + 
  DimPlot(merged, label = TRUE, group.by = 'seurat_clusters_res1.2') 
```

### Save Object
At last, let's save our object for future analysis.

```R
setwd(outdir)
saveRDS(merged, file = "rep135_clustered.rds")
```





















